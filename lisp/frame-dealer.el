;;; frame-dealer.el --- set frame position according to any dealing rule.

;;; Commentary:

;;; Code:

(require 'frame)
(require 'nadvice)
(require 'seq)

(defgroup frame-dealer nil
  "Set frame position according to any dealing rule when `make-frame'."
  :group 'frames)

(defvar frame-dealer-dealing-rule nil
  "Function accoding to which frame-dealer set frame position.

Specified function should return list whose car and cadr are integer,
otherwise frame-dealer leave control of frame position to window system.
Each element of the list are treated as car:left cadr:top of frame position.

Specified function must take one argument, frame object which can be used
as a model of frame to be dealt. In many cases, passed frame object is usefull
for determinating position. However, passed frame object can be ignored.")

(defcustom frame-dealer-dealing-rules '(frame-dealer-random
                                        frame-dealer-perturbation)
  "List of dealing rules."
  :type '(repeat function))

(defcustom frame-dealer-use-hook nil
  "When non-nil `frame-dealer' set frame position by using hook
`after-make-frame-functions' instead of using advice by which frame dealer add
positional parameter to arguments of `make-frame'"
  :type 'boolean
  :group 'frame-dealer)

(defcustom frame-dealer-lighter " FD"
  "Lighter for frame-dealer-mode"
  :type 'string
  :group 'frame-dealer)

(defcustom frame-dealer-perturbation-metric 200
  "Metric for perturbation of frame position"
  :type 'integer
  :group 'frame-dealer)

(defvar frame-dealer--model-frames nil
  "Model frames which could not be deleted instantly for any reason")

(defun frame-dealer--generate-positional-frame-parameters (frame)
  "Generate alist containing positional frame parameters,
i.e. left, top, and user-position.
left, and top value are generated by `frame-dealer-dealing-rule' for FRAME.
If FRAME is nil, it defaults to the selected frame."
  (if (functionp frame-dealer-dealing-rule)
      (let* ((frame (or frame (selected-frame)))
             (position (funcall frame-dealer-dealing-rule frame))
             (left (car position))
             (top (cadr position)))
        (if (and (integerp left)
                 (integerp top))
            `((user-position . t)
              (left . (+ ,left))
              (top . (+ ,top)))))))

(defun frame-dealer--prepend-positional-frame-parameters (args)
  "Filter for `make-frame' arguments. This function is intended to be used as
:fileter-args for `make-frame' in `nadvice' frame work.

This function take `make-frame' arguments and return arguments prepended by
positional parameters. In order to generate positional parameters,
`frame-dealer--generate-positional-frame-parameters' is called with dummy frame
object which is generated by `make-frame' with passed arguments ARGS."
  (with-temp-buffer
    (let* ((param (car args))
           (selected-frame (selected-frame))
           (model-frame
            (unless (or (assq 'left param)
                        (assq 'top param))
              (advice-remove 'make-frame #'frame-dealer--filtering-dipatcher)
              (unwind-protect
                  (let ((frame-alpha-lower-limit 0))
                    (let ((frame (make-frame
                                  `((alpha . 0) (wait-for-wm . nil) ,@param))))
                      (modify-frame-parameters frame '((visibility . nil)))
                      frame))
                (select-frame selected-frame)
                (advice-add 'make-frame
                            :filter-args #'frame-dealer--filtering-dipatcher))))
           (positional-parameters
            (unwind-protect
                (if (and model-frame
                         (assq 'display (frame-parameters model-frame)))
                    (frame-dealer--generate-positional-frame-parameters
                     model-frame))
              (if model-frame
                  (if (frame-dealer--single-frame-client-p
                       (frame-parameter model-frame 'client))
                      (add-to-list 'frame-dealer--model-frames model-frame)
                    (delete-frame model-frame 'force))))))
      `((,@positional-parameters ,@param)))))

(defun frame-dealer--prepend-visibility-nil (args)
  "Filter for `make-frame' arguments. This function is intended to be used as
:fileter-args for `make-frame' in `nadvice' frame work.

This function take `make-frame' arguments and return arguments prepended by
\(visibility . nil\). When this function added to make-frame, made frame is
forced to be invisible."
  `(((visibility . nil) ,@(car args))))

(defun frame-dealer--make-visible (frame)
  "Set FRAME visibility visible."
  (modify-frame-parameters frame '((visibility . t))))

(defun frame-dealer--single-frame-client-p (client)
  "Return t if passed argument CLIENT has just one frame, otherwise return nil"
  (letrec ((find-client-frame
            (lambda (fl fn)
              (cond ((null fl) (if (zerop fn) nil t))
                    ((eq (frame-parameter (car fl) 'client) client)
                     (if (< 0 fn)
                         nil
                       (funcall find-client-frame (cdr fl) (+ 1 fn))))
                    (t (funcall find-client-frame (cdr fl) fn))))))
    (funcall find-client-frame (frame-list) 0)))

(defun frame-dealer--clean-model-frames (frame)
  "Delete frames stored in `frame-dealer--model-frames' if each frame does not
satisfy some exceptional condition."
  (letrec ((check-and-delete
            (lambda (fl)
              (cond ((null fl) nil)
                    ((frame-dealer--single-frame-client-p
                      (frame-parameter (car fl) 'client))
                     (cons (car fl) (funcall check-and-delete (cdr fl))))
                    (t (delete-frame (car fl) 'force)
                       (funcall check-and-delete (cdr fl)))))))
    (setq frame-dealer--model-frames
          (funcall check-and-delete frame-dealer--model-frames))))

(defun frame-dealer--filtering-dipatcher (args)
  "Filtering dispatcher for advice as filter-args on `make-frame'."
  (if frame-dealer-use-hook
      (frame-dealer--prepend-visibility-nil args)
    (frame-dealer--prepend-positional-frame-parameters args)))

(defun frame-dealer--post-processing-dispatcher (frame)
  "Post processing dispatcher for hook `after-make-frame-functions'"
  (if frame-dealer-use-hook
      (progn (frame-dealer-deal-frame frame)
             (frame-dealer--make-visible frame))
    (frame-dealer--clean-model-frames frame)))

;;;###autoload
(define-minor-mode frame-dealer-mode
  "Toggle `frame-dealer-mode'.

In `frame-dealer-mode', frame position is set according to
`frame-dealer-dealing-rule' automatically when `make-frame'."
  :group 'frame-dealer
  :global t
  :lighter frame-dealer-lighter
  (if frame-dealer-mode
      (progn
        (advice-add 'make-frame
                    :filter-args #'frame-dealer--filtering-dipatcher)
        (add-hook 'after-make-frame-functions
                  #'frame-dealer--post-processing-dispatcher))
    (advice-remove 'make-frame
                   #'frame-dealer--filtering-dipatcher)
    (remove-hook 'after-make-frame-functions
                 #'frame-dealer--post-processing-dispatcher)))

;;;###autoload
(defun frame-dealer-set-rule (rule)
  "Set rule from rules stored in `frame-dealer-dealing-rules'."
  (interactive (list (intern (completing-read
                              "Rule: "
                              (remq frame-dealer-dealing-rule
                                    frame-dealer-dealing-rules)))))
  (setq frame-dealer-dealing-rule rule))

(defun frame-dealer-random (frame)
  "Dealing rule to set frame position randomly."
  (let* ((workarea-list (mapcar (lambda (attributes)
                                  (cdr (assq 'workarea attributes)))
                                (display-monitor-attributes-list
                                 (frame-parameter frame 'display))))
         (frame-width (if frame (frame-pixel-width frame) 0))
         (frame-height (if frame (frame-pixel-height frame) 0))
         (pseudo-left
          (random (- (apply #'+ (mapcar (lambda (workarea) (nth 2 workarea))
                                        workarea-list))
                     (* frame-width (length workarea-list)))))
         (monitor-and-remainder
          (letrec ((find-monitor
                    (lambda (wl pl index)
                      (let ((h-area (- (nth 2 (car wl)) frame-width)))
                        (cond ((or (null wl) (< pl 0))
                               (error "Generated left is invalid"))
                              ((< pl h-area) (cons index pl))
                              (t (funcall
                                  find-monitor
                                  (cdr wl) (- pl h-area) (1+ index))))))))
            (funcall find-monitor workarea-list pseudo-left 0)))
         (left (+ (nth 0 (nth (car monitor-and-remainder) workarea-list))
                  (cdr monitor-and-remainder)))
         (top (+ (nth 1 (nth (car monitor-and-remainder) workarea-list))
                 (random
                  (nth 3 (nth (car monitor-and-remainder) workarea-list))))))
    `(,left ,top)))

(defun frame-dealer-perturbation (frame)
  "Dealing rule to set frame position according to window system, and
after set by window system perturb position."
  (let* ((left (if frame (frame-parameter frame 'left) 0))
         (top (if frame (frame-parameter frame 'top) 0))
         (left-bound (- left frame-dealer-perturbation-metric))
         (top-bound (- top frame-dealer-perturbation-metric))
         (right-bound (+ left frame-dealer-perturbation-metric))
         (bottom-bound (+ top frame-dealer-perturbation-metric))
         (width (if frame (frame-pixel-width frame) 0))
         (height (if frame (frame-pixel-height frame) 0))
         (workarea-list (mapcar (lambda (attributes)
                                  (cdr (assq 'workarea attributes)))
                                (display-monitor-attributes-list
                                 (frame-parameter frame 'display))))
         (monitor (letrec ((find-monitor
                            (lambda (wl index)
                              (cond ((null wl)
                                     (error "Original frame has no monitor"))
                                    ((and (and (<= (nth 0 (car wl)) left)
                                               (< left (+ (nth 0 (car wl))
                                                          (nth 2 (car wl)))))
                                          (and (<= (nth 1 (car wl)) top)
                                               (< top (+ (nth 1 (car wl))
                                                         (nth 3 (car wl))))))
                                     index)
                                    (t (funcall find-monitor
                                                (cdr wl) (1+ index)))))))
                    (funcall find-monitor workarea-list 0)))
         (left-edge (nth 0 (nth monitor workarea-list)))
         (top-edge (nth 1 (nth monitor workarea-list)))
         (right-edge (- (+ (nth 0 (nth monitor workarea-list))
                           (nth 2 (nth monitor workarea-list)))
                        width))
         (bottom-edge (- (+ (nth 1 (nth monitor workarea-list))
                            (nth 3 (nth monitor workarea-list)))
                         height)))
    (if (< left-bound left-edge) (setq left-bound left-edge))
    (if (< top-bound top-edge) (setq top-bound top-edge))
    (if (< right-edge right-bound) (setq right-bound right-edge))
    (if (< bottom-edge bottom-bound) (setq bottom-bound bottom-edge))
    `(,(+ left-bound (random (- right-bound left-bound)))
      ,(+ top-bound (random (- bottom-bound top-bound))))))

;;;###autoload
(defun frame-dealer-deal-frame (&optional frame)
  "Set FRAME position according to `frame-dealer-dealing-rule'
If FRAME is nil, it defaults to the selected frame."
  (interactive)
  (if (assq 'display (frame-parameters frame))
      (let ((alist (frame-dealer--generate-positional-frame-parameters frame)))
        (if alist (modify-frame-parameters frame alist)))))

(provide 'frame-dealer)

;;; frame-dealer.el ends here
